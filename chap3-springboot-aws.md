## 3장

### 패러다임 불일치
관계형 데이터베이스는 **어떻게 데이터를 저장할지**에 초점이 맞춰진 기술  
객체지향 프로그래밍 언어는 **메시지를 기반으로 기능과 속성을 한 곳에서 관리하는 기술**  
-> 패러다임 불일치가 발생한다.

```java
// User와 Group은 부모-자식 관계
User user = findUser();
Group group = user.getGroup();

// User 따로, Group 따로 조회하게 된다.
User user = userDao.findUser();
Group group = groupDao.findGroup(user.getGroupId());
```


JPA는 서로 지향하는 바가 다른 2개 영역을 중간에서 패러다임 일치 시켜주기 위한 기술이다. -> SQL에 종속적인 개발을 하지 않아도 된다.

### Spring Data JPA
```text
JPA <- Hibernate <- Spring Data JPA
```
한 단계 더 감싸놓은 이유  
* 구현체 교체의 용이성  
* 저장소 교체의 용이성  

### Repository
`JpaRepository<Entity 클래스, PK 타입>`  
@Repository 추가할 필요 없다.  
Entity 클래스와 기본 Entity Repository는 함께 위치해야한다.  
Entity 클래스는 기본 Repository 없이는 제대로 역할을 할 수가 없다. 둘은 매우 밀접한 관계 -> 도메인 패키지에서 함께 관리한다.  


```text
Hibernate: create table posts (id bigint generated by default as identity, author varchar(255), content TEXT not null, title varchar(500) not null, primary key (id))
```
`id bigint generated by default as identify`라는 옵션으로 생성된다. 이는 H2의 쿼리 문법이 적용되었다. H2는 MySQL의 쿼리를 수행해도 정상적으로 동작하기 때문에 출력되는 로그를 MYSql 버전으로 바꾸기 위해서는
다음과 같은 property를 추가해주면 된다.

```text
// application.properties
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL5InnoDBDialect
```

### 등록/수정/조회 API 만들기 (p.100)
